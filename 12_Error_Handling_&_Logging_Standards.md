
# 12. Error Handling & Logging Standards

*バージョン: 1.0.0 | 最終更新日: 2025年5月14日*

## 目次

1.  [はじめに](#1-はじめに)
    *   1.1 本書の目的
    *   1.2 重要性と原則
2.  [エラーハンドリング戦略](#2-エラーハンドリング戦略)
    *   2.1 エラーの分類と定義
    *   2.2 例外処理の基本方針
    *   2.3 フロントエンド (Next.js/React) におけるエラーハンドリング
    *   2.4 バックエンド (Python/FastAPI) におけるエラーハンドリング
    *   2.5 AIコンポーネントにおけるエラーハンドリング
    *   2.6 サードパーティ連携におけるエラーハンドリング
    *   2.7 ユーザーへのエラー通知
    *   2.8 再試行戦略
3.  [ロギング戦略](#3-ロギング戦略)
    *   3.1 ログレベルの定義と使用基準
    *   3.2 構造化ログの標準フォーマット
    *   3.3 ログに含めるべき情報 (必須・推奨)
    *   3.4 フロントエンドロギング
    *   3.5 バックエンドロギング
    *   3.6 AIコンポーネントのロギング
    *   3.7 サードパーティ連携のロギング
    *   3.8 機密情報のマスキングとログのセキュリティ
    *   3.9 ログの集約と管理
4.  [特定のユースケースにおけるエラー処理とログ](#4-特定のユースケースにおけるエラー処理とログ)
    *   4.1 データ入力・バリデーションエラー
    *   4.2 データベースアクセスエラー
    *   4.3 AIモデル推論エラー
    *   4.4 外部API呼び出しエラー
    *   4.5 非同期タスク処理エラー
    *   4.6 認証・認可エラー
5.  [デバッグとトラブルシューティング](#5-デバッグとトラブルシューティング)
    *   5.1 ログ分析による問題特定
    *   5.2 分散トレーシングの活用
    *   5.3 デバッグツールの利用
6.  [ベストプラクティスとガイドライン](#6-ベストプラクティスとガイドライン)

## 1. はじめに

*   **1.1 本書の目的**
    このドキュメントは、HRX-AIアプリケーションにおけるエラーハンドリングとロギングに関する標準的なアプローチ、ガイドライン、およびベストプラクティスを定義することを目的としています。これにより、システムの堅牢性、保守性、および問題解決の効率性を向上させることを目指しています。

*   **1.2 重要性と原則**
    *   **エラーハンドリングの重要性**
        *   ユーザーエクスペリエンスの維持 (予期せぬクラッシュや曖昧なエラーメッセージの回避)。
        *   システムの安定性と信頼性の確保。
        *   データ整合性の保護。
        *   問題の早期発見と迅速な原因究明。
    *   **ロギングの重要性**
        *   システムの動作状況の可視化。
        *   デバッグとトラブルシューティングの主要な情報源。
        *   パフォーマンス分析と最適化の手がかり。
        *   セキュリティ監査とインシデント分析の証拠。
        *   ユーザー行動分析 (限定的、プライバシー配慮)。
    *   **基本原則**
        *   **明確性** エラーメッセージは具体的で理解しやすく、ログは必要な情報を含み構造化されている。
        *   **一貫性** アプリケーション全体でエラー処理とログ形式のスタイルを統一する。
        *   **網羅性** 予期されるエラーだけでなく、予期せぬエラーも適切に捕捉し記録する。
        *   **効率性** 過度なロギングによるパフォーマンス劣化を避け、必要な情報のみを記録する。
        *   **安全性** ログに機密情報（パスワード、APIキー、個人識別情報など）を含めないようにマスキングする。

## 2. エラーハンドリング戦略

*   **2.1 エラーの分類と定義**
    *   **ユーザー起因エラー (Client Errors, HTTP 4xx系)**
        *   例 不正な入力、権限不足、リソースが見つからない。
        *   対応 ユーザーに明確なエラーメッセージを返し、修正を促す。
    *   **システム起因エラー (Server Errors, HTTP 5xx系)**
        *   例 データベース接続失敗、外部APIタイムアウト、コードのバグ、リソース不足。
        *   対応 ユーザーには汎用的なエラーメッセージを返し、詳細なエラー情報をログに記録。アラートを発し、開発者/運用者が調査。
    *   **ビジネスロジックエラー**
        *   例 重複登録、不正な状態遷移、ビジネスルール違反。
        *   対応 ユーザーに具体的な理由を説明し、適切なアクションを促す。
    *   **AIモデル関連エラー**
        *   例 推論失敗、不適切なコンテンツ生成、信頼度が低い予測。
        *   対応 フォールバック処理、ユーザーへの注意喚起、再試行、エラーログ記録。

*   **2.2 例外処理の基本方針**
    *   **早期リターンとフェイルファスト**
        *   関数の早い段階で入力や前提条件をチェックし、問題があれば速やかにエラーを返して処理を中断する。
    *   **具体的な例外クラスの使用**
        *   Pythonの標準例外 (ValueError, TypeError, KeyErrorなど) や、FastAPIの `HTTPException`、カスタム例外クラスを適切に使用し、エラーの種類を明確にする。
    *   **例外の捕捉と再スロー**
        *   低レベルの例外を捕捉し、よりコンテキストに合った高レベルのカスタム例外として再スローすることを検討。ただし、スタックトレースの情報を失わないように注意 (`raise NewException from original_exception`)。
    *   **`finally` ブロックの活用**
        *   リソースの解放 (ファイルクローズ、DBコネクション解放など) は `finally` ブロックで行い、エラー発生時でも確実に実行されるようにする。コンテキストマネージャ (`with` 文) の利用を推奨。
    *   **エラー境界 (Error Boundaries) の設定 (React)**
        *   Reactコンポーネントツリーの一部で発生したJavaScriptエラーが、アプリケーション全体をクラッシュさせないように、エラー境界コンポーネントを適切に配置する。

*   **2.3 フロントエンド (Next.js/React) におけるエラーハンドリング**
    *   **API呼び出しエラー**
        *   `TanStack Query` (React Query) のエラーハンドリング機能 (`onError` コールバック, `isError`, `error` プロパティ) を活用。
        *   ユーザーに適切なフィードバック (トースト通知、エラーメッセージ表示) を行う。
        *   必要に応じて再試行ロジック (`retry` オプション) を設定。
    *   **コンポーネントレンダリングエラー**
        *   React Error Boundaries を使用して、UIの一部がクラッシュしても他の部分が機能し続けるようにする。
        *   エラー境界内でエラー情報をログに送信し、ユーザーにはフォールバックUIを表示。
        *   ```tsx
            // components/ErrorBoundary.tsx
            // import React, { Component, ErrorInfo, ReactNode } from "react";
            //
            // interface Props {
            //   children: ReactNode;
            //   fallbackUI?: ReactNode;
            // }
            // interface State {
            //   hasError: boolean;
            //   error?: Error;
            // }
            //
            // class ErrorBoundary extends Component<Props, State> {
            //   public state: State = { hasError: false };
            //
            //   public static getDerivedStateFromError(error: Error): State {
            //     return { hasError: true, error };
            //   }
            //
            //   public componentDidCatch(error: Error, errorInfo: ErrorInfo) {
            //     // console.error("Uncaught error:", error, errorInfo);
            //     // logErrorToService(error, errorInfo); // 外部ログサービスへ送信
            //   }
            //
            //   public render() {
            //     if (this.state.hasError) {
            //       return this.props.fallbackUI || <h1>Sorry.. there was an error</h1>;
            //     }
            //     return this.props.children;
            //   }
            // }
            // export default ErrorBoundary;
            ```
    *   **フォームバリデーションエラー**
        *   ZodやReact Hook Formなどのライブラリを使用し、ユーザーに分かりやすいエラーメッセージをフィールドごとに表示。
    *   **非同期処理エラー (Promise)**
        *   `.catch()` や `async/await` の `try...catch` ブロックで適切に処理。

*   **2.4 バックエンド (Python/FastAPI) におけるエラーハンドリング**
    *   **グローバル例外ハンドラ**
        *   `Development_Specification.md` 8.2.4 で示したような、FastAPIの `@app.exception_handler` を使用して、アプリケーション全体で一貫したエラーレスポンス形式を保証し、予期せぬ例外も捕捉してログに記録。
        *   ユーザーにはエラーIDのみを返し、詳細はサーバーログに記録。
    *   **HTTPExceptionの活用**
        *   クライアント起因のエラー (バリデーションエラー、リソース未発見、権限不足など) には、FastAPIの `HTTPException` を適切なステータスコードと詳細メッセージ (または翻訳キー) と共に送出。
    *   **カスタム例外クラス**
        *   ビジネスロジック固有のエラーや、特定のドメインエラーに対してカスタム例外クラスを定義。これにより、エラーの種類に応じたきめ細やかなハンドリングが可能になる。
        *   ```python
            # backend/app/core/custom_exceptions.py
            # class BusinessLogicError(Exception):
            #     def __init__(self, message_key: str, status_code: int = 400, **kwargs):
            #         self.message_key = message_key
            #         self.status_code = status_code
            #         self.params = kwargs
            #         super().__init__(message_key) # メッセージキーを親クラスのメッセージとする
            #
            # # グローバル例外ハンドラでCustomAPIExceptionを処理
            # @app.exception_handler(BusinessLogicError)
            # async def business_logic_exception_handler(request: Request, exc: BusinessLogicError):
            #     # locale = request.headers.get("accept-language", "en").split(',')[0].split('-')[0]
            #     # message = gettext_for_locale(locale, exc.message_key).format(**exc.params)
            #     message = f"Business Error: {exc.message_key}" # 簡易版
            #     return JSONResponse(
            #         status_code=exc.status_code,
            #         content={"message_key": exc.message_key, "detail": message}
            #     )
            ```
    *   **Pydanticバリデーションエラーのカスタマイズ**
        *   FastAPIはPydanticモデルによるリクエストバリデーションエラーを自動的に処理するが、必要に応じて `RequestValidationError` のハンドラをカスタマイズし、エラーレスポンス形式を統一。

*   **2.5 AIコンポーネントにおけるエラーハンドリング**
    *   **LLM API呼び出しエラー**
        *   APIキー無効、レート制限超過、サーバーエラー、タイムアウト、コンテンツフィルターによるブロックなど、LLMプロバイダーが返す各種エラーをハンドリング。
        *   適切な再試行ロジック (指数バックオフ) を実装。
        *   ユーザーには「AIアシスタントが一時的に利用できません」のような汎用メッセージを返し、詳細はログ記録。
    *   **推論エラー (カスタムモデル)**
        *   不正な入力データ、モデルロード失敗、リソース不足 (GPUメモリなど) による推論エラーを捕捉。
        *   可能であれば、フォールバックモデルやルールベースの処理に切り替え。
    *   **RAGシステムエラー**
        *   ベクトルデータベース検索失敗、ドキュメント取得エラー、コンテキスト構築エラーなどをハンドリング。
        *   部分的に結果が得られた場合は、その旨をユーザーに伝えて限定的な情報を提供するなど、グレースフルな劣化を検討。
    *   **AI生成コンテンツの品質問題**
        *   生成されたコンテンツが不適切 (ハルシネーション、バイアス、有害コンテンツ) である場合、コンテンツセーフティフィルター (セクション 5.3参照) で検出し、ユーザーへの表示をブロックまたは修正。
        *   品質が低いと判断された場合は、「期待した回答を生成できませんでした」のようなメッセージを返す。

*   **2.6 サードパーティ連携におけるエラーハンドリング**
    *   **API呼び出しエラー**
        *   外部APIの接続エラー、タイムアウト、HTTPエラーステータスコード (4xx, 5xx) をハンドリング。
        *   各APIのエラードキュメントを参照し、特定のエラーコードに応じた処理を実装。
    *   **Webhook処理エラー**
        *   Webhook受信時の署名検証失敗、ペイロード解析エラー、処理中のエラーなどをハンドリング。
        *   リトライ可能なエラーは、メッセージキューに積んで後で再処理。致命的なエラーはログに記録し、アラート。
    *   **データ同期エラー**
        *   データマッピングエラー、バリデーションエラー、外部システムへの書き込み失敗などをハンドリング。
        *   失敗したレコードや理由を記録し、手動介入や再同期のトリガーとする。

*   **2.7 ユーザーへのエラー通知**
    *   **明確かつ簡潔**: ユーザーが理解できる言葉で、何が問題で、次に何をすべきか (またはできないか) を示す。技術的な詳細は避ける。
    *   **エラーIDの提示**: ユーザーがサポートに問い合わせる際に役立つ一意のエラーIDを表示 (サーバーログと紐付けられるように)。
    *   **アクション可能な情報**: 可能であれば、ユーザーが問題を自己解決できるようなヒントやリンクを提供。
    *   **トーン＆マナー**: 共感的で丁寧な言葉遣いを心がける。
    *   **国際化**: エラーメッセージも国際化の対象 (4.2参照)。

*   **2.8 再試行戦略**
    *   **対象**: 一時的な問題 (ネットワークの不安定、外部サービスの瞬間的な過負荷、レート制限など) で発生する可能性のあるエラー。
    *   **方法**:
        *   **指数バックオフ (Exponential Backoff)**: 再試行の間隔を徐々に長くしていく (例 1秒, 2秒, 4秒, 8秒...)。
        *   **ジッター (Jitter)**: 再試行間隔にランダムな要素を加え、複数のクライアントが同時に再試行するのを避ける。
        *   **最大再試行回数**: 無限ループを防ぐため、最大試行回数を設定。
    *   **ライブラリ**: Python `tenacity`, JavaScript `async-retry` など。

## 3. ロギング戦略

`Development_Specification.md` 8.2.4「エラーハンドリングとトラブルシューティング」および `5. AI Integration Playbook` 8.2.1「構造化ログの標準」に基づき、効果的なロギング戦略を定義します。

*   **3.1 ログレベルの定義と使用基準**
    *   **DEBUG**
        *   用途: 開発中の詳細な情報、診断情報、変数の値など。本番環境では通常無効化。
        *   例: 「User {user_id} requested data with filters: {filters}」
    *   **INFO**
        *   用途: システムの通常動作、主要なイベント、リクエストの開始・終了、状態変化など。
        *   例: 「User {user_id} logged in successfully from IP {ip_address}」, 「Report {report_id} generated in {duration_ms} ms」
    *   **WARNING**
        *   用途: 予期しないが、システム動作を直ちに停止させるほどではない問題。潜在的な問題の兆候。軽微なエラー。
        *   例: 「API rate limit approaching for {api_service}」, 「Deprecated feature {feature_name} used by user {user_id}」, 「Optional configuration file not found, using defaults.」
    *   **ERROR**
        *   用途: システムの一部機能が正常に動作しなかったエラー。処理は継続できるかもしれないが、何らかの問題が発生している。
        *   例: 「Failed to process message from queue: {message_id}, reason: {reason}」, 「Database query failed for user {user_id}: {sql_error}」
    *   **CRITICAL**
        *   用途: システム全体または主要なコンポーネントが停止するような致命的なエラー。即時の対応が必要。
        *   例: 「Application startup failed: Database connection refused」, 「Unrecoverable error in payment processing module」
    *   **本番環境のデフォルトログレベル**: `INFO` 以上。必要に応じて一時的に `DEBUG` に変更可能にする。

*   **3.2 構造化ログの標準フォーマット (JSON)**
    *   **方針**
        *   すべてのログはJSON形式で出力し、機械処理と分析を容易にします。
        *   `5. AI Integration Playbook` 8.2.1 の `CustomJsonFormatter` のようなフォーマッタを使用。
    *   **主要フィールド** (8.2.1 の共通フィールド例を参照)
        *   `timestamp` (ISO 8601)
        *   `level` (DEBUG, INFO, WARNING, ERROR, CRITICAL)
        *   `message` (ログメッセージ本体)
        *   `service_name` (例 hrx-ai-frontend, hrx-ai-backend, hrx-ai-rag-service)
        *   `module`, `funcName`, `lineno`
        *   `correlation_id` (リクエスト追跡用)
        *   `request_id` (個別リクエスト)
        *   `user_id` (可能な場合)
        *   `model_id` (AI関連ログ)
        *   `duration_ms` (処理時間)
        *   `error_code`, `error_type`, `stack_trace` (エラー時)
        *   `extra_data` (任意のキーバリューペアのカスタム情報)

*   **3.3 ログに含めるべき情報 (必須・推奨)**
    *   **必須**
        *   いつ (timestamp)
        *   どこで (service_name, module, funcName, lineno)
        *   何が (message, event_type)
        *   どの程度の重要度か (level)
    *   **推奨 (コンテキストに応じて)**
        *   誰が (user_id, client_ip)
        *   どのリクエストに関連するか (correlation_id, request_id)
        *   処理対象の主要エンティティID (employee_id, job_id, candidate_id)
        *   入力の主要パラメータ (ダイジェストまたはマスキングされたもの)
        *   処理結果の要約 (成功/失敗、件数など)
        *   外部システムコール時の情報 (宛先サービス、リクエストID、応答ステータス)

*   **3.4 フロントエンドロギング**
    *   **対象**: ユーザーインタラクション、APIリクエスト/レスポンス (ヘッダーやステータス)、JavaScriptエラー、パフォーマンスメトリクス (Web Vitals)、コンポーネントライフサイクルイベント (デバッグ時)。
    *   **ツール**:
        *   ブラウザの `console.log/warn/error` (開発時)。
        *   クライアントサイドロギングサービス (Sentry, LogRocket, Datadog RUMなど) と連携し、エラーやパフォーマンスデータを集約・分析。
    *   **注意点**: ユーザーのブラウザで実行されるため、ログ量が過大にならないように注意。機密情報をクライアントサイドログに含めない。

*   **3.5 バックエンドロギング**
    *   **対象**: APIリクエスト受信とレスポンス送信、ビジネスロジックの主要ステップ、データベース操作、外部API呼び出し、非同期タスクの実行、認証・認可イベント、エラーと例外。
    *   **ツール**: Python標準 `logging` モジュール + `python-json-logger`。FastAPIのミドルウェアを利用してリクエストごとの共通ログ情報を自動的に付加。
    *   **`correlation_id` の伝播**: リクエストの最初 (例 ミドルウェア) で生成または外部から受け取った `correlation_id` を、後続のすべての処理ステップやサービス呼び出しのログに含める。`contextvars` を利用すると便利。

*   **3.6 AIコンポーネントのロギング** (`5. AI Integration Playbook` 8.2.3 参照)
    *   **プロンプトとレスポンス**: (マスキング済み) プロンプト、LLMからの生のレスポンス、トークン数、レイテンシ。
    *   **RAGプロセス**: 検索クエリ、検索結果のドキュメントIDとスコア、最終的なコンテキスト。
    *   **予測モデル**: 入力特徴量のダイジェスト、予測結果、信頼度スコア。
    *   **モデルバージョン**: 使用したモデルのバージョン情報。
    *   **コンテンツセーフティフィルター**: 判定結果、検出された問題のカテゴリ。

*   **3.7 サードパーティ連携のロギング**
    *   **リクエスト**: 宛先サービス、エンドポイント、(マスキング済み)リクエストボディ/ヘッダー。
    *   **レスポンス**: ステータスコード、(マスキング済み)レスポンスボディ/ヘッダー、レイテンシ。
    *   **Webhook**: 受信したペイロードのダイジェスト、署名検証結果、処理結果。
    *   エラー発生時の外部システムからのエラーメッセージやエラーコード。

*   **3.8 機密情報のマスキングとログのセキュリティ**
    *   **方針**
        *   ログにパスワード、APIキー、クレジットカード情報、詳細な個人識別情報 (PII) などの機密情報が平文で記録されないように徹底します。
    *   **実装**
        *   **マスキング**: 機密情報を含む可能性のあるフィールド (例 HTTPヘッダーの `Authorization`, リクエストボディの特定フィールド) は、ロギング前にマスキング処理 (例 `****` で置換、ハッシュ化) を行います。専用のログフィルターやフォーマッタで実装。
        *   **Pydanticモデルの活用**: Pydanticモデルのフィールドに `SecretStr` 型を使用したり、カスタムシリアライザでログ出力時にマスキングしたりする。
        *   **ログへのアクセス制御**: ログ管理システムへのアクセス権限を厳格に管理し、必要な担当者のみがアクセスできるようにします。
        *   **ログの暗号化**: 保存時のログ暗号化 (at rest) を検討 (ログ管理システムまたはストレージ機能)。
        *   **ログ保持期間**: 法的要件と分析ニーズに基づき、ログの保持期間を設定 (例 30日、90日、1年)。古いログはアーカイブまたは削除。

*   **3.9 ログの集約と管理**
    *   **ツール**: Elastic Stack (Elasticsearch, Logstash, Kibana), Grafana Loki, Splunk, Datadog, Google Cloud Logging, AWS CloudWatch Logs など。`Development_Specification.md` 2.5 「OpenTelemetry」と連携可能なものが望ましい。
    *   **収集エージェント**: Fluentd, Fluent Bit, OpenTelemetry Collector。
    *   **インデックス戦略 (Elasticsearchなど)**: タイムスタンプベースのインデックス作成。検索パフォーマンスとストレージ効率を考慮したシャーディングとレプリケーション設定。
    *   **ダッシュボードとアラート**: KibanaやGrafanaでログデータを可視化するダッシュボードを作成。特定のログパターン (例 エラー多発、セキュリティイベント) に基づいてアラートを設定。

## 4. 特定のユースケースにおけるエラー処理とログ

*   **4.1 データ入力・バリデーションエラー**
    *   **エラー処理**: FastAPI/Pydanticによる自動バリデーションエラー (HTTP 422 Unprocessable Entity) をフロントエンドに返す。エラーレスポンスには、どのフィールドがなぜ無効だったかの詳細を含める。
    *   **ログ**: `INFO` レベルでバリデーションエラーが発生した旨と、エラー箇所、(マスキングされた) 入力値を記録。頻発する場合は `WARNING` レベルでログを出し、入力フォームやAPI仕様の改善を検討。
*   **4.2 データベースアクセスエラー**
    *   **エラー処理**: 接続エラー、タイムアウト、クエリエラー (デッドロック、制約違反など) を捕捉。一時的なエラーは再試行。永続的なエラーは HTTP 500 Internal Server Error を返し、ユーザーには汎用メッセージを表示。
    *   **ログ**: `ERROR` または `CRITICAL` レベル。(マスキングされた) 実行クエリ、エラーコード、DBからのエラーメッセージ、スタックトレースを記録。
*   **4.3 AIモデル推論エラー**
    *   **エラー処理**: LLM APIからのエラー (レート制限、認証エラー、サーバーエラー、コンテンツフィルター) や、カスタムモデルの推論エンジンエラーを個別にハンドリング。可能であればフォールバック処理 (よりシンプルなモデル、ルールベース、キャッシュされた結果など)。
    *   **ログ**: `ERROR` レベル。使用モデル、(マスキングされた) 入力プロンプト/データ、APIからのエラーレスポンス全文、推論エンジンのエラー詳細を記録。
*   **4.4 外部API呼び出しエラー**
    *   **エラー処理**: 接続タイムアウト、DNS解決失敗、HTTPエラーステータス (4xx, 5xx) をハンドリング。`Retry-After` ヘッダーがあればそれに従って再試行。
    *   **ログ**: `WARNING` (4xx系) または `ERROR` (5xx系、接続エラー)。宛先サービス、エンドポイント、リクエストメソッド、ステータスコード、レスポンスボディ (一部またはダイジェスト) を記録。
*   **4.5 非同期タスク処理エラー (例 Celery, FastAPI BackgroundTasks)**
    *   **エラー処理**: タスク実行中の例外を捕捉。タスクごとにリトライポリシー (最大試行回数、バックオフ) を設定。リトライ上限を超えた場合はタスクを失敗としてマークし、手動介入が必要な場合は通知。
    *   **ログ**: `ERROR` レベル。タスクID、タスク名、引数 (マスキング済み)、試行回数、エラー詳細、スタックトレースを記録。
*   **4.6 認証・認可エラー**
    *   **エラー処理**: 認証失敗 (無効なトークン、期限切れなど) は HTTP 401 Unauthorized。認可失敗 (権限不足) は HTTP 403 Forbidden。
    *   **ログ**: `INFO` または `WARNING` レベル (攻撃の可能性も考慮)。試行されたユーザーID (もしあれば)、アクセストークンのダイジェスト、要求されたリソース、IPアドレス、ユーザーエージェントを記録。失敗が繰り返される場合は `WARNING` または `ERROR` としてアラート。

## 5. デバッグとトラブルシューティング

*   **5.1 ログ分析による問題特定**
    *   ログ集約プラットフォーム (Kibana, Grafana Lokiなど) の検索・フィルタリング機能を活用。
    *   `correlation_id` でリクエストの処理フロー全体を追跡。
    *   エラー発生時刻周辺のログを `ERROR`, `CRITICAL` レベルで確認。
    *   特定の `user_id` や `service_name` でフィルタリング。
*   **5.2 分散トレーシングの活用** (`Development_Specification.md` 2.5 OpenTelemetry, `5. AI Integration Playbook` 8.2.5)
    *   Jaeger, Zipkin, Grafana Tempoなどのツールで、リクエストが複数のマイクロサービスやコンポーネントを横断する際の各スパンのレイテンシやエラーを確認。
    *   ボトルネックとなっている箇所や、エラーの発生源を特定。
*   **5.3 デバッグツールの利用**
    *   **ローカル開発**: IDEのデバッガ (VSCode, PyCharmなど)。Python `pdb`。ブラウザ開発者ツール。
    *   **リモートデバッグ (慎重に)**: 本番環境での直接デバッグは避ける。ステージング環境で、必要な場合に限定してリモートデバッグツールを利用。
    *   **AIデバッグツール**: LangSmith (LangChain利用時)、Weights & Biases (モデル実験・評価時)。

## 6. ベストプラクティスとガイドライン

*   **ログレベルを適切に使い分ける**: 過度なDEBUGログは本番で無効に。INFOは主要な処理フロー、ERRORは対応が必要な問題。
*   **具体的で意味のあるメッセージ**: ログメッセージは、何が起こったのか、なぜ起こったのか、どのようなコンテキストで起こったのかが分かるように記述。
*   **ログに機密情報を含めない**: パスワード、APIキー、PIIなどは絶対に平文で記録しない。マスキングを徹底。
*   **相関IDを一貫して使用する**: マイクロサービス環境では特に重要。
*   **エラーハンドリングは具体的かつ網羅的に**: `try...except Exception:` のような包括的なキャッチは避け、予期される例外を個別に処理。予期せぬ例外はグローバルハンドラで捕捉。
*   **ユーザーに返すエラーメッセージは簡潔に**: 技術的な詳細はログに。ユーザーにはエラーIDと一般的な対処法を。
*   **定期的なログレビューとアラートチューニング**: ログのパターンを分析し、不要なログの削減やアラート閾値の最適化を行う。
*   **ドキュメント化**: エラーコードの意味、主要なログイベントの種類などをドキュメントとして整備。
