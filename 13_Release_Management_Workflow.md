
# 13. Release Management Workflow

*バージョン: 1.0.0 | 最終更新日: 2025年5月14日*

## 目次

1.  [はじめに](#1-はじめに)
    *   1.1 本書の目的
    *   1.2 リリースの種類と定義
    *   1.3 リリース管理の原則
2.  [リリース計画](#2-リリース計画)
    *   2.1 リリースサイクルと頻度
    *   2.2 リリーススコープの決定 (フィーチャー、バグ修正)
    *   2.3 リソース計画と役割分担
    *   2.4 リリース候補ブランチ戦略
3.  [開発とテストフェーズ](#3-開発とテストフェーズ)
    *   3.1 機能開発とユニットテスト
    *   3.2 コードレビューとマージ
    *   3.3 統合テストとCIパイプライン
    *   3.4 ステージング環境でのテスト
4.  [リリース準備フェーズ](#4-リリース準備フェーズ)
    *   4.1 リリース候補 (RC) のビルドとデプロイ
    *   4.2 リグレッションテスト
    *   4.3 パフォーマンステスト (必要に応じて)
    *   4.4 セキュリティレビュー (必要に応じて)
    *   4.5 UAT (ユーザー受け入れテスト)
    *   4.6 リリースノートの作成
    *   4.7 ロールバック計画の最終確認
    *   4.8 変更管理委員会 (CCB) / リリース承認
5.  [リリース実行フェーズ](#5-リリース実行フェーズ)
    *   5.1 デプロイメントウィンドウの計画と通知
    *   5.2 本番環境へのデプロイ
    *   5.3 スモークテストとヘルスチェック
    *   5.4 段階的ロールアウト戦略 (カナリアリリース、フィーチャーフラグ)
    *   5.5 データベースマイグレーション (必要な場合)
    *   5.6 キャッシュのクリアとウォーミングアップ
6.  [リリース後フェーズ](#6-リリース後フェーズ)
    *   6.1 本番環境監視強化
    *   6.2 ユーザーフィードバックの収集と分析
    *   6.3 ホットフィックスプロセス (緊急バグ修正)
    *   6.4 リリースレビュー (Post-mortem / Retrospective)
7.  [ツールと自動化](#7-ツールと自動化)
8.  [コミュニケーション計画](#8-コミュニケーション計画)
9.  [緊急リリースプロセス](#9-緊急リリースプロセス)

## 1. はじめに

*   **1.1 本書の目的**
    このドキュメントは、HRX-AIアプリケーションの新機能、改善、バグ修正を、計画的かつ統制された方法で本番環境にリリースするための標準的なワークフローと手順を定義することを目的としています。これにより、リリースの品質、信頼性、予測可能性を高め、ユーザーへの影響を最小限に抑えます。

*   **1.2 リリースの種類と定義**
    *   **メジャーリリース**
        *   大規模な新機能、大幅なUI変更、アーキテクチャ変更などを含む。通常、計画的なリリースサイクル (例 四半期ごと) に従う。広範なテストとUATが必要。
    *   **マイナーリリース**
        *   既存機能の改善、中規模の新機能、複数のバグ修正を含む。メジャーリリースより頻繁 (例 月次)。
    *   **パッチリリース (ホットフィックス)**
        *   本番環境で発見されたクリティカルなバグ修正、または緊急性の高いセキュリティ修正。計画外で迅速にリリースされる。スコープは最小限。
    *   **AIモデルリリース**
        *   新しいAIモデルのデプロイ、既存モデルのバージョンアップや再学習済みモデルへの切り替え。他のアプリケーションリリースとは独立したサイクルで管理される場合もあるが、連携は必要。

*   **1.3 リリース管理の原則**
    *   **自動化** 可能な限りビルド、テスト、デプロイプロセスを自動化する。
    *   **再現性** 同じ手順で常に同じ結果が得られるリリースプロセスを目指す。
    *   **可観測性** リリースプロセスの各ステップの状況が追跡可能であること。
    *   **安全性** ロールバック計画を常に準備し、本番影響を最小限に抑える。
    *   **コミュニケーション** 関係者 (開発、QA、運用、プロダクト、ユーザーサポートなど) との明確でタイムリーなコミュニケーション。
    *   **品質重視** リリース前に定義された品質ゲートをクリアすること。

## 2. リリース計画

`Development_Specification.md` 5.1 3ヶ月開発タイムライン、5.2 アジャイル開発プロセス、および11.3 ブランチ戦略・リリースフローに基づき計画します。

*   **2.1 リリースサイクルと頻度**
    *   **初期開発フェーズ (MVPリリースまで)**
        *   `Development_Specification.md` 5.1 に従い、3ヶ月後の初期リリースを目指す。この期間中は、スプリントごとの内部リリース (ステージング環境へ) を行い、フィードバックを迅速に反映。
    *   **MVPリリース後 (継続的改善フェーズ)**
        *   アジャイル開発プロセス (1週間スプリント) を継続。
        *   マイナーリリース: 2〜4週間ごと (スプリント1〜2回分) を目標とし、新機能や改善を定期的に提供。
        *   メジャーリリース: 四半期ごと、または大規模な戦略的機能の準備が整い次第。
        *   パッチリリース: 必要に応じて随時。

*   **2.2 リリーススコープの決定**
    *   プロダクトマネージャー、開発リード、QAリードが協議し、次のリリースに含めるフィーチャー、ユーザーストーリー、バグ修正を決定。Jiraなどの課題管理ツールで追跡。
    *   各アイテムの優先度、開発工数、依存関係、リスクを考慮。
    *   AIモデルの更新が含まれる場合は、その影響範囲とテスト計画もスコープに含める。

*   **2.3 リソース計画と役割分担**
    *   **リリースオーナー**: リリースプロセス全体に責任を持つ担当者 (通常はプロダクトマネージャーまたは開発リード)。
    *   **開発チーム**: 機能開発、バグ修正、ユニットテスト、コードレビュー。
    *   **QAチーム**: テスト計画、テストケース作成、テスト実行、バグレポート。
    *   **DevOps/SREチーム**: CI/CDパイプライン管理、デプロイ実行、インフラ準備、監視。
    *   **AI/MLチーム**: AIモデルの準備、テスト、デプロイ。
    *   関係者のアサインとスケジュールを確認。

*   **2.4 リリース候補ブランチ戦略**
    *   `Development_Specification.md` 11.3 Git Flow実装方法 に従うことを基本とする。
    *   **`main` (または `master`) ブランチ**: 常に最新のリリース可能な安定版コードを保持。本番環境はこのブランチからデプロイされる。
    *   **`develop` ブランチ**: 現在開発中の最新コードを統合するブランチ。CIパイプラインがこのブランチの変更を常にテスト。
    *   **フィーチャーブランチ (`feature/...`)**: 各新機能や改善は `develop` から派生したフィーチャーブランチで開発。完了後、`develop` へマージ (プルリクエスト経由)。
    *   **リリースブランチ (`release/vX.Y.Z`)**
        *   マイナー/メジャーリリースの準備開始時に `develop` ブランチから作成。
        *   このブランチでは、リリースに向けたバグ修正、ドキュメント作成、最終テストのみを行う。新たなフィーチャー開発は行わない。
        *   リリース承認後、`main` ブランチと `develop` ブランチの両方にマージ。`main` ブランチにはリリースタグ (例 `v1.0.0`) を付与。
    *   **ホットフィックスブランチ (`hotfix/...`)**
        *   本番環境のクリティカルなバグ修正のために `main` ブランチから直接作成。
        *   修正後、`main` ブランチと `develop` ブランチ (および進行中のリリースブランチがあればそれにも) にマージ。

## 3. 開発とテストフェーズ

*   **3.1 機能開発とユニットテスト**
    *   開発者はフィーチャーブランチで機能開発またはバグ修正を行う。
    *   `7. Testing Strategy & Test Cases` 2.1 に従い、自身のコードに対するユニットテストを作成・実行。コードカバレッジ目標を意識。
    *   AIモデル開発の場合は、モデルの単体テスト (精度、入力バリデーションなど) を実施。
*   **3.2 コードレビューとマージ**
    *   フィーチャーブランチでの作業完了後、`develop` ブランチへのプルリクエスト (PR) を作成。
    *   PRには、変更内容、テスト結果、関連する課題IDなどを記述。
    *   チームメンバー (1名以上) によるコードレビューを実施。レビュー観点には、ロジックの正当性、コーディング規約 (`Development_Specification.md` 11.2) 遵守、セキュリティ、パフォーマンス、テストカバレッジなどを含む。
    *   レビューでの指摘事項修正後、承認を得て `develop` ブランチにマージ。
*   **3.3 統合テストとCIパイプライン**
    *   `develop` ブランチへのマージをトリガーとして、CIパイプライン (GitHub Actions/Circle CI) が自動的に実行。
    *   CIパイプラインには、ビルド、ユニットテスト、統合テスト (APIレベル)、静的コード解析、依存関係スキャンが含まれる。
    *   テスト失敗時はビルドを失敗させ、開発者に通知。
*   **3.4 ステージング環境でのテスト**
    *   CIパイプライン成功後、`develop` ブランチの最新コードが定期的に (例 毎日夜間) または手動トリガーでステージング環境に自動デプロイされる。
    *   ステージング環境で、QAチームが統合テスト (より広範な)、E2Eテスト、ユーザビリティテスト、アクセシビリティテストなどを実施。
    *   発見されたバグはJiraに登録し、開発チームが修正。

## 4. リリース準備フェーズ

*   **4.1 リリース候補 (RC) のビルドとデプロイ**
    *   リリースブランチ (`release/vX.Y.Z`) を作成後、このブランチからリリース候補ビルドを作成。
    *   RCビルドをステージング環境 (または専用のRC環境) にデプロイ。
*   **4.2 リグレッションテスト**
    *   QAチームが、RCビルドに対して包括的なリグレッションテストを実施。自動化されたリグレッションテストスイートを実行し、主要な手動テストシナリオもカバー。
    *   `7. Testing Strategy & Test Cases` 2.10 参照。
*   **4.3 パフォーマンステスト (必要に応じて)**
    *   メジャーリリースや、パフォーマンスに影響を与える可能性のある変更が含まれる場合、ステージング環境で負荷テスト、ストレステストを実施。
    *   `7. Testing Strategy & Test Cases` 2.6 および `9. Performance Optimization Guide` 7. 参照。
*   **4.4 セキュリティレビュー (必要に応じて)**
    *   メジャーリリースや、セキュリティに影響を与える可能性のある変更が含まれる場合、セキュリティチーム (または担当者) によるセキュリティレビューや簡易的な脆弱性スキャンを実施。
    *   `7. Testing Strategy & Test Cases` 2.7 参照。
*   **4.5 UAT (ユーザー受け入れテスト)**
    *   QAチームまたはプロダクトマネージャーが主導し、選定された実際のユーザー (または社内の代表ユーザー) がステージング環境でRCビルドを検証。
    *   `7. Testing Strategy & Test Cases` 2.11 参照。
    *   フィードバックを収集し、クリティカルな問題があれば修正。
*   **4.6 リリースノートの作成**
    *   プロダクトマネージャーと開発リードが協力し、今回のリリースに含まれる新機能、改善点、修正されたバグ、既知の問題点などをまとめたリリースノートを作成。
    *   内部向け (開発チーム、サポートチーム) と外部向け (ユーザー) の両方を準備。
*   **4.7 ロールバック計画の最終確認**
    *   `8. Deployment & Infrastructure Runbook` 3.7 ロールバック手順 を参照し、今回のリリース特有の注意点がないか、ロールバック手順が最新であることを確認。
    *   ロールバック判断基準 (例 特定のクリティカルエラー数、パフォーマンス目標未達など) を明確化。
*   **4.8 変更管理委員会 (CCB) / リリース承認**
    *   リリースオーナーが、テスト結果、UATフィードバック、リスク評価、ロールバック計画などをまとめ、CCB (構成メンバー プロダクト、開発、QA、運用、セキュリティの各代表) に提示。
    *   CCBがリリース可否を最終判断し、承認。承認されなければ、問題点を修正し再レビュー。

## 5. リリース実行フェーズ

*   **5.1 デプロイメントウィンドウの計画と通知**
    *   本番環境へのデプロイ作業を行う時間帯 (デプロイメントウィンドウ) を計画。ユーザーへの影響が少ない時間帯 (例 深夜、早朝、週末) を選定。
    *   メンテナンスウィンドウを事前にユーザーに通知 (必要な場合)。
    *   関係者 (運用チーム、開発オンコール担当など) にデプロイ計画を共有。
*   **5.2 本番環境へのデプロイ**
    *   承認されたリリースブランチ (または `main` ブランチの特定コミット/タグ) から本番環境へデプロイ。
    *   CI/CDパイプラインを通じて自動化されていることが望ましい。
    *   `8. Deployment & Infrastructure Runbook` のデプロイ手順 (3.2, 3.3, 3.4) に従う。
*   **5.3 スモークテストとヘルスチェック**
    *   デプロイ完了後、直ちに主要機能が正常に動作しているかを確認するスモークテストを実施 (自動または手動)。
        *   例 ログイン、主要ダッシュボード表示、コア機能の簡単な操作。
    *   システム全体のヘルスチェック (APIエンドポイント、データベース接続、AIモデル推論エンドポイント) を実行。
*   **5.4 段階的ロールアウト戦略 (カナリアリリース、フィーチャーフラグ)**
    *   **方針**
        *   リスクの高い変更や大規模な新機能については、一度に全ユーザーに展開せず、段階的にロールアウトすることで影響を限定し、問題発生時の迅速な対応を可能にする。
    *   **カナリアリリース**
        *   ごく一部のユーザー (例 全体の1%, 5%) に新バージョンを先行公開し、問題がないことを確認しながら徐々にトラフィックの割合を増やしていく。
        *   Vercel (Incremental Rollouts), Railway/Fly.io (ロードバランサーやサービスメッシュ設定), Cloudflare (Traffic Manager) などのプラットフォーム機能を利用。
        *   `5. AI Integration Playbook` 6.1 のカナリアアップデート戦略も参照。
    *   **フィーチャーフラグ (Feature Toggles)**
        *   新機能をコードに組み込みつつ、フィーチャーフラグによって特定のユーザーやグループに対してのみ機能を有効化/無効化できるようにする。
        *   リリース後でも、問題があれば該当機能を即座に無効化できる。
        *   LaunchDarkly, Optimizelyなどの専用サービス、または自社実装 (例 Firebase Remote Config, 環境変数ベース)。
*   **5.5 データベースマイグレーション (必要な場合)**
    *   アプリケーションのデプロイと同期して、またはその直前にデータベーススキーマのマイグレーションを実行。
    *   ダウンタイムを最小化するため、オンラインマイグレーションやブルー/グリーンデプロイメントと組み合わせたマイグレーション戦略を検討。
    *   `8. Deployment & Infrastructure Runbook` 3.5 参照。
*   **5.6 キャッシュのクリアとウォーミングアップ**
    *   デプロイ後、関連するCDNキャッシュ、ブラウザキャッシュ、サーバーサイドキャッシュなどを必要に応じてクリア (またはバージョニングにより自動更新)。
    *   重要なページやAPIエンドポイントに対して、キャッシュウォーミングアップ (事前にアクセスしてキャッシュを生成) を行うことを検討。

## 6. リリース後フェーズ

*   **6.1 本番環境監視強化**
    *   リリース直後は、主要メトリクス (エラーレート、レイテンシ、リソース使用率など) の監視レベルを一時的に上げ、通常より注意深くシステムの挙動を監視。
    *   `8. Deployment & Infrastructure Runbook` 4. 運用監視とアラート 参照。
*   **6.2 ユーザーフィードバックの収集と分析**
    *   ユーザーサポートチャネル、アンケート、アプリ内フィードバック機能などを通じて、新機能や変更点に関するユーザーからのフィードバックを積極的に収集。
    *   問題点や改善要望をJiraなどに記録し、次の開発サイクルに反映。
*   **6.3 ホットフィックスプロセス (緊急バグ修正)**
    *   本番環境でクリティカルなバグが発見された場合の緊急修正プロセス。
    1.  **問題特定と影響評価**: 迅速にバグの原因を特定し、ユーザーへの影響範囲と深刻度を評価。
    2.  **修正**: ホットフィックスブランチ (`main` から作成) で最小限のコード変更で修正。
    3.  **レビューとテスト**: 緊急であっても、最低限のコードレビューと修正箇所に特化したテストを実施。
    4.  **緊急デプロイ**: 通常のリリースプロセスを短縮し、迅速に本番環境へデプロイ。
    5.  **事後対応**: 修正内容を `develop` ブランチにも必ずマージ。インシデントレポートを作成。
*   **6.4 リリースレビュー (Post-mortem / Retrospective)**
    *   各メジャー/マイナーリリースの完了後、関係者で振り返りを実施。
    *   うまくいった点、問題点、改善点を洗い出し、次のリリースプロセスに活かす。
    *   指標 (例 リリースに要した時間、デプロイ成功率、リリース後のバグ数) を用いてプロセスを評価。

## 7. ツールと自動化

*   **バージョン管理**: Git (GitHub, GitLabなど)
*   **CI/CD**: GitHub Actions, CircleCI (`Development_Specification.md` 2.5)
*   **課題管理**: Jira, Asana, Trello
*   **テスト管理**: TestRail, Zephyr (Jiraプラグイン), Xray (Jiraプラグイン)
*   **デプロイメントプラットフォーム**: Vercel, Railway, Fly.io (`Development_Specification.md` 2.5)
*   **コンテナ**: Docker, Kubernetes (`Development_Specification.md` 2.5) (Kubernetesは将来的な大規模運用を想定)
*   **監視**: Prometheus, Grafana, OpenTelemetry, 各PaaSの監視機能, Sentry, Datadog (`Development_Specification.md` 2.5, `8. Deployment & Infrastructure Runbook` 4.2)
*   **フィーチャーフラグ管理**: LaunchDarkly, Optimizely, Firebase Remote Config
*   **ドキュメント・コミュニケーション**: Confluence, Notion, Slack, Microsoft Teams

## 8. コミュニケーション計画

*   **リリース前**
    *   開発チーム内: リリーススコープ、スケジュール、タスク割り当ての共有。
    *   社内関係者 (プロダクト, QA, サポート, マーケティング): リリース内容、デモ、トレーニング資料の提供。
    *   ユーザー (必要な場合): 大規模変更やメンテナンスウィンドウに関する事前通知。
*   **リリース中**
    *   デプロイチーム内: 作業進捗、問題発生時のリアルタイム連携。
    *   関係者: デプロイ開始、主要ステップ完了、完了/問題発生の通知。
*   **リリース後**
    *   社内関係者: リリース成功/失敗の報告、ユーザーフィードバックの共有。
    *   ユーザー: 新機能や改善点に関するアナウンス (ブログ、メール、アプリ内通知)。リリースノート公開。

## 9. 緊急リリースプロセス (ホットフィックス)

6.3 ホットフィックスプロセスをより詳細化。

1.  **検知と報告**: 本番障害の検知 (監視アラート、ユーザー報告など)。インシデントとして起票。
2.  **初期評価**: インシデントマネージャー (または代理) が影響範囲、深刻度を評価。ホットフィックスの必要性を判断。
3.  **原因特定と修正案策定**: 担当開発者が迅速に原因を調査し、最小限の修正案を策定。
4.  **緊急CCB承認 (簡略版)**: 関係者 (開発リード、QAリード、リリースオーナーなど) による修正案のレビューと承認。リスクと影響を考慮。
5.  **修正とビルド**: ホットフィックスブランチで修正コードを作成。ユニットテストは必須。CIパイプラインでビルドと基本テストを実行。
6.  **限定的テスト**: ステージング環境で修正箇所に特化したテストを実施。広範なリグレッションテストは時間的制約から省略する場合があるが、リスクを評価。
7.  **緊急デプロイ**: 本番環境へデプロイ。通常より監視体制を強化。
8.  **動作確認**: スモークテストと、修正された問題が解決していることを確認。
9.  **事後処理**:
    *   修正内容を `develop` および関連ブランチにマージ。
    *   インシデントレポート作成 (原因、対応、影響、再発防止策)。
    *   必要に応じて、ユーザーへのコミュニケーション。
